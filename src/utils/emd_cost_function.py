import scipy
from scipy.stats import wasserstein_distance_nd
import torch

from src.evolutionary.nets.generator_methods import from_patches_to_image, from_probs_to_pixels


def emd_scoring_function(real_images_preloaded, num_images_to_compare, qc,
                         n_tot_qubits, n_ancillas, n_patches,
                         pixels_per_patch, patch_width, patch_height, sim):
    """
    Computes the Earth Mover's Distance (EMD), aka Wasserstein distance, between a batch of real
    images and a batch of images generated by a quantum circuit. The goal is to evaluate the
    quality of the images generated by the quantum circuit. A lower EMD score indicates that the
    distribution of the generated images is closer to the target distribution (real images).
    Hence lower score indicates better quantum circuit. A score of 0 indicates that the
    distributions are identical. Note: EMD has no upper bound.

    :param real_images_preloaded: tensor. Preloaded real images.
    :param num_images_to_compare: int. The number of images used to calculate em-distance.
    :param qc: qiskit.circuit.quantumcircuit.QuantumCircuit. The qc that generates images.
    :param n_tot_qubits: int. The total number of qubits in the quantum circuit.
    :param n_ancillas: int. The number of ancillary qubits in the quantum circuit.
    :param n_patches: int. The number of patches that each image is divided into for processing.
    :param pixels_per_patch: int. The number of pixels that constitute each patch.
    :param patch_width: int. The width (in pixels) of each image patch.
    :param patch_height: int. The height (in pixels) of each image patch.
    :param sim: StatevectorSimulator. The simulator that executes the qc to generate image patches.

    :return: float. The Earth Mover's Distance between the real and generated images.
    """
    generated_images_list = []
    if n_patches > 1:
        for batch_index in range(num_images_to_compare):
            generated_image = from_probs_to_pixels(quantum_circuit=qc,
                                                   n_tot_qubits=n_tot_qubits,
                                                   n_ancillas=n_ancillas,
                                                   sim=sim)[:pixels_per_patch]

            generated_image = generated_image.reshape(1, patch_height, patch_width)
            generated_images_list.append(generated_image)

    else:
        for batch_index in range(num_images_to_compare):
            generated_image = from_patches_to_image(quantum_circuit=qc,
                                                    n_tot_qubits=n_tot_qubits,
                                                    n_ancillas=n_ancillas,
                                                    n_patches=n_patches,
                                                    pixels_per_patch=pixels_per_patch,
                                                    patch_width=patch_width,
                                                    patch_height=patch_height,
                                                    sim=sim)
            generated_images_list.append(generated_image)

    real_images_tensor = torch.stack(real_images_preloaded, dim=0)
    generated_images_tensor = torch.stack([torch.from_numpy(image).float() for image in generated_images_list])

    real_images_flat = real_images_tensor.reshape(num_images_to_compare, -1)
    generated_images_flat = generated_images_tensor.reshape(num_images_to_compare, -1)

    # real_images_flat_np = real_images_flat.cpu().detach().numpy()
    # generated_images_flat_np = generated_images_flat.cpu().detach().numpy()

    # wasserstein_distance_nd expects tensors or vectors shaped so that each row is a vector
    # observation or possible value (so in this case an flattened image or patch), and each
    # column, so the second dimension, is the number of samples. For example, when measuring the
    # distance between two batches of 25 patches of size (2x28), the vectors should have shape
    # (25, 56), so 25 rows of 56 pixels each
    distance_real_gen = wasserstein_distance_nd(u_values=real_images_flat,
                                                v_values=generated_images_flat)

    return distance_real_gen
